// Fill out your copyright notice in the Description page of Project Settings.

#pragma once

#include "CoreMinimal.h"
#include "../ProjectSolisActorComponent.h"
#include "CharacterPawnMovementComponent.generated.h"

enum class EKPCMovementMode : uint8
{
	Walking
};

/**
 *
 */
UCLASS()
class PROJECTSOLIS_API UCharacterPawnMovementComponent : public UProjectSolisActorComponent
{
	GENERATED_BODY()

private:
	// Scalar value scaling world gravity applied to the pawn.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|General")
	float GravityScale = 3.0f;

	// If enabled the component will update the pawn's rotation to match movement direction. This setting is ignored if the pawn has root motion data for the current frame.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|General|Rotation", meta = (DisplayName = "Orient Rotation To Movement"))
	bool bOrientRotationToMovement = true;

	// Controls the interpolation speed (degrees/second) the pawn rotates at when orienting rotation.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|General|Rotation", meta = (EditCondition = "bOrientRotationToMovement"))
	FRotator OrientRotationRate = FRotator(0.0, 900.0, 0.0);

	// When OrientRotationToMovementInput is true, orients the pawn's pitch towards the movement input direction.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|General|Rotation", meta = (DisplayName = "Orient Pitch", EditCondition = "bOrientRotationToMovement"))
	bool bOrientPitch = false;

	// When OrientRotationToMovementInput is true, orients the pawn's yaw towards the movement input direction.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|General|Rotation", meta = (DisplayName = "Orient Yaw", EditCondition = "bOrientRotationToMovement"))
	bool bOrientYaw = true;

	// When OrientRotationToMovementInput is true, orients the pawn's roll towards the movement input direction.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|General|Rotation", meta = (DisplayName = "Orient Roll", EditCondition = "bOrientRotationToMovement"))
	bool bOrientRoll = false;

	// If enabled the pawn will still have its orientation rotated to match movement input added with AddMovementInput when a root motion animation is playing on the RootMotionMesh.
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "KinematicPawnController|General|Rotation",
		meta = (DisplayName = "Allow Movement Rotation During Root Motion", EditCondition = "bOrientRotationToMovement", AllowPrivateAccess = "true"))
	bool bAllowMovementRotationDuringRootMotion = false;

	// The maximum speed the pawn can walk at on the horizontal plane.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float MaxWalkSpeed = 500.0f;

	// The maximum acceleration rate the pawn accelerates on the horizontal plane at. Represents the maximum amount of energy the pawn can exert to move in the desired direction.
	// This value needs to be set relative to GroundFriction to obtain desired acceleration behaviour. Affects the amount of time the pawn takes to reach MaxWalkSpeed 
	// and how quickly the pawn can change directions when walking on surfaces with low friction. This is the max acceleration rate because it can be scaled down by movement input.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float MaxAccelerationRate = 4000.0f;

	// A value of 0 represents a perfect smooth surface and a value of 1 represents a perfect rough surface. Applied in ground friction calculation to scale the ground friction value.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float FrictionCoefficient = 0.1f;

	// Represents the total friction generated by the surface when the pawn slides on it. A higher friction value will allow the pawn to make tighter turns and change directions
	// quicker however, will require a higher MaxAccelerationRate value to be able to reach MaxWalkSpeed as the movement force must be larger than the friction force to move. 
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float GroundFriction = 50.0f;

	// The rate at which the pawn decelerates at on the horizontal plane when there is no movement input being added. Braking deceleration force is the only force used to
	// slow down the character.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float BrakingDecelerationRate = 3000.0f;

	// If this is true only braking deceleration will be used to stop the character when there is no movement input otherwise braking force has friction added to it when stopping
	// the pawn.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	bool bApplySeperateBrakingForce = true;

	// The maximum speed the pawn will accelerate up to and walk at on the horizontal plane when an analog input device is being used.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float MinAnalogWalkSpeed = 0.0f;

	// Value used to scale the horizontal movement force when the character pawn is in the air. A value of 0 will yield no horizontal movement control in the air
	// and a value of 1 will yield full horizontal movement control in the air. 
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float AirControl = 0.175f;

	// The amount of upwards force applied to the character when they jump.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float JumpZForce = 400.0f;

	// The maximum speed the pawn can fall at.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float MaxFallSpeed = 2000.0f;

	// If this is true all velocity will be removed when the pawn lands on a walkable surface removing the need for the pawn to brake to a stop and instead immediately
	// come to a stop.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking", meta = (DisplayName = "Remove Velocity On Land"))
	bool bRemoveVelocityOnLand = true;

	// The maximum height the pawn can step up onto.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float MaxStepHeight = 25.0f;

	// The minimum amount of distance there must be available on a step to step up onto.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float MinStepDepth = 10.0f;

	// The maximum angle (in degrees) of slope that the pawn can walk on.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Walking")
	float MaxWalkableSlopeAngle = 40.01f;

	// Value used to offset sample points used to determine if the pawn is on the ground from the bottom center location of the movement collision primitive.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	float DetermineGroundedSampleMod = 0.15f;

	// The distance to offset grounded traces upwards from the base of the movement collision before tracing downwards for ground collision.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	float DetermineGroundedOffset = 20.0f;

	// The distance below the pawn to check for ground collision when determining if the pawn is on the ground. This value should remain greater than the Pull 
	// Back Movement Epsilon value and greater than the Sweep Shape Inflation Amount value added to Additional Depenetration Fixup value.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	float DetermineGroundedDistance = 1.5f;

	// Epsilon value used in PullBackMovement() to account for floating point precision.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	float PullBackMovementEpsilon = 0.125f;

	// The amount the movement collision shape is inflated when checking for initial overlapping collisions when the pawn is attempting to move.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	float SweepShapeInflationAmount = 0.25f;

	// Addition value added to the found penetration depth when calculating a depenetration vector when resolving initial overlap collisions when the pawn is attempting
	// to move.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	float AdditionalDepenetrationDistance = 0.125f;

	// Whether to trace movement collision traces against complex collision.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	bool MovementTraceComplex = false;

	// Collision channel movement collision traces are made in.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	TEnumAsByte<ECollisionChannel> MovementTraceChannel = ECollisionChannel::ECC_Visibility;

	// The maximum distance used to search for collision when snapping the pawn down onto a surface.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	float MaxSnapDownDistance = 1000.0f;

	// The maximum number of iterations used to move the pawn through the world while testing for collisions and sliding along collided surfaces.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	int32 MaxMoveAndSlideIterations = 3;

	// The maximum number of iterations used to resolve initial overlapping collisions when the pawn is attempting to move.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	int32 MaxPenetrationResolutionIterations = 16;

	// The pawn will be able to step up onto step surfaces with an available step depth value below MinStepDepth when the step collision height is below this value. This 
	// helps with stepping up when colliding with shallow slopes.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	float StepDepthCollisionHeightThreshold = 7.5f;

	// The distance (in cm) used to search below the pawn for collision to determine if the character is walking off of a ledge.
	UPROPERTY(EditAnywhere, Category = "KinematicPawnController|Advanced")
	float LedgeSearchDistance = 45.0f;

	// Variables internal to component.
	UWorld* World = nullptr;
	UPrimitiveComponent* UpdatedComponent = nullptr;
	USkeletalMeshComponent* RootMotionMesh = nullptr;
	FCollisionQueryParams MovementCollisionQueryParams = FCollisionQueryParams::DefaultQueryParam;
	FRootMotionMovementParams RootMotionMovementParams = {};
	bool bIsAnimMontagePlaying = false;
	EKPCMovementMode MovementMode = EKPCMovementMode::Walking;
	FVector MovementInputDirection = FVector::ZeroVector;
	float MovementInputScale = 0.0f;
	TArray<FHitResult> HitResultScratch = {};

	// Movement mode walking variables.
	FVector InitialHorizontalVelocityWalking = FVector::ZeroVector;
	FVector InitialVerticalVelocityWalking = FVector::ZeroVector;

public:
	// Sets the component the kinematic pawn controller updates. This is the component that is transformed in the world by the kinematic pawn controller component.
	void SetUpdatedComponent(UPrimitiveComponent* Component);

	// Sets the skeletal mesh component the kinematic pawn controller should extract root bone animation data from if root motion is being used.
	void SetRootMotionMesh(USkeletalMeshComponent* Component);

	// Adds movement input to the pawn.
	void AddMovementInput(const FVector& Direction, float Scale);

	// Makes the pawn jump when in walking movement mode.
	void Jump();

	// Returns true if the pawn is grounded. Only valid for walking movement mode.
	UFUNCTION(BlueprintCallable, BlueprintPure)
	bool IsGrounded() const;

	// Apply a force underneath the pawn to launch them vertically.
	void AddVerticalForce(float Force);

	UFUNCTION(BlueprintCallable, BlueprintPure)
	FVector GetVelocity() const;

private:
	// Constructor.
	UCharacterPawnMovementComponent();

	// UProjectSolisActorComponent interface.
	virtual void BeginPlay() override;
	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;

	// General component functions.
	void ClearMovementInput();
	bool IsRequestingMovement();
	bool HasRootMotion();
	float CalculateGravity();
	FVector PullBackMovement(const FVector& Movement);
	bool DepenetrateAndSweep(FHitResult& OutHit, const FVector& Displacement, const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation,
		const FCollisionShape& MovementCollisionShape);
	void UpdatePawnRotation(float DeltaTime);
	void MoveOutOfCollision(const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation, const FCollisionShape& MovementCollisionShape);
	double CalculateOrientRotationComponentDelta(double Current, double Target, float DeltaTime, float Speed);

	// Movement mode walking functions.
	void TickMovementModeWalking(float DeltaTime, const FVector& MovementCollisionLocation, const FCollisionShape& MovementCollisionShape, const FQuat& MovementCollisionRotation);
	void UpdateHorizontalMovementWalking(float Time, const FCollisionShape& MovementCollisionShape, const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation);
	void UpdateVerticalMovementWalking(float Time, const FCollisionShape& MovementCollisionShape, const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation);
	bool StepUp(const FHitResult& CollisionHitResult, const FVector& Velocity, const FCollisionShape& MovementCollisionShape, const FVector& MovementCollisionLocation,
		const FQuat& MovementCollisionRotation);
	void SnapDownToSurface(float InMaxSnapDownDistance, const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation, const FCollisionShape& MovementCollisionShape);
	void MoveAndSlideHorizontalWalking(const FVector& Displacement, const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation,
		const FCollisionShape& MovementCollisionShape);
	void MoveAndSlideVerticalWalking(const FVector& Displacement, const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation,
		const FCollisionShape& MovementCollisionShape);
	bool IsWalkableSurface(const FVector& SurfaceNormal) const;
	FVector FindStepSurfaceNormalFromCollision(const FHitResult& Hit);
	FHitResult FindGroundHit(const FCollisionShape& MovementCollisionShape, const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation) const;
	bool DetermineIfGrounded(const FCollisionShape& MovementCollisionShape, const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation) const;
	FVector FindGroundSurfaceNormal(const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation, const FCollisionShape& MovementCollisionShape);
	void UpdateComponentAttachment(const FCollisionShape& MovementCollisionShape, const FVector& MovementCollisionLocation, const FQuat& MovementCollisionRotation);
	FVector AdjustDepenetrationNormalWalking(FVector Normal, const FVector& ImpactNormal);
	void ApplyRootMotionRotationWalking(const FQuat& Rotation);
	FRotator GetMovementOrientationWalking();
	void ApplyVerticalForceWalking(float Force);
	FVector GetVelocityWalking() const;
	// Called when the pawn lands on a walkable surface after vertical movement during ticking walking movement mode.
	void OnLandedWalking();
};
